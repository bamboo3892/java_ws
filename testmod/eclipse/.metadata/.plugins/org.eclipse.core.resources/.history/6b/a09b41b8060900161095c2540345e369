package com.test.client.renderer;

import org.lwjgl.opengl.GL11;

import com.test.multiblock.construct.tileentity.ConstructContainerTileEntity;

import net.minecraft.block.Block;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;
import net.minecraft.entity.item.EntityItem;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntity;

public class TileContainerRenderer extends TileEntitySpecialRenderer {

	public TileContainerRenderer() {

	}

	@Override
	public void renderTileEntityAt(TileEntity tileEntity, double tileX, double tileY, double tileZ, float partialTicks) {
		Tessellator tessellator = Tessellator.instance;
		GL11.glPushMatrix();
		GL11.glEnable(GL11.GL_BLEND);
		GL11.glDisable(GL11.GL_TEXTURE_2D);
		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
		GL11.glDepthMask(false);

		double d;
		double d2;
		tessellator.startDrawing(GL11.GL_LINE_STRIP);
		tessellator.setColorRGBA_F(1.0F, 1.0F, 1.0F, 0.5F);
		d = 1.0D;
		d2 = 1.0D;
		//y neg
		tessellator.addVertexWithUV(tileX, tileY, tileZ, 0, 0);
		tessellator.addVertexWithUV(tileX, tileY, tileZ + d, 0, d2);
		tessellator.addVertexWithUV(tileX + d, tileY, tileZ + d, d2, d2);
		tessellator.addVertexWithUV(tileX + d, tileY, tileZ, d2, 0);
		//y pos
		tessellator.addVertexWithUV(tileX, tileY + d, tileZ, 0, 0);
		tessellator.addVertexWithUV(tileX + d, tileY + d, tileZ, 0, d2);
		tessellator.addVertexWithUV(tileX + d, tileY + d, tileZ + d, d2, d2);
		tessellator.addVertexWithUV(tileX, tileY + d, tileZ + d, d2, 0);
		//z neg
		tessellator.addVertexWithUV(tileX, tileY, tileZ, 0, 0);
		tessellator.addVertexWithUV(tileX, tileY + d, tileZ, d2, 0);
		tessellator.addVertexWithUV(tileX, tileY + d, tileZ + d, d2, d2);
		tessellator.addVertexWithUV(tileX, tileY, tileZ + d, 0, d2);
		//z pos
		tessellator.addVertexWithUV(tileX + d, tileY, tileZ, 0, 0);
		tessellator.addVertexWithUV(tileX + d, tileY, tileZ + d, d2, 0);
		tessellator.addVertexWithUV(tileX + d, tileY + d, tileZ + d, d2, d2);
		tessellator.addVertexWithUV(tileX + d, tileY + d, tileZ, 0, d2);
		//x neg
		tessellator.addVertexWithUV(tileX, tileY, tileZ, 0, 0);
		tessellator.addVertexWithUV(tileX + d, tileY, tileZ, 0, d2);
		tessellator.addVertexWithUV(tileX + d, tileY + d, tileZ, d2, d2);
		tessellator.addVertexWithUV(tileX, tileY + d, tileZ, d2, 0);
		///x pos
		tessellator.addVertexWithUV(tileX, tileY, tileZ + d, 0, 0);
		tessellator.addVertexWithUV(tileX, tileY + d, tileZ + d, 0, d2);
		tessellator.addVertexWithUV(tileX + d, tileY + d, tileZ + d, d2, d2);
		tessellator.addVertexWithUV(tileX + d, tileY, tileZ + d, d2, 0);
		tessellator.draw();

		GL11.glDepthMask(true);
		GL11.glEnable(GL11.GL_TEXTURE_2D);
		GL11.glDisable(GL11.GL_BLEND);
		GL11.glPopMatrix();

		if(tileEntity instanceof ConstructContainerTileEntity){
			ConstructContainerTileEntity container = (ConstructContainerTileEntity) tileEntity;
			if(container.getStackInSlot(0) != null){
				float ticks = container.getWorldObj().getTotalWorldTime() + partialTicks;
				GL11.glPushMatrix();
				GL11.glTranslatef((float) tileX + 0.5F, (float) tileY + 0.3F, (float) tileZ + 0.5F);
				GL11.glScalef(2F, 2F, 2F);
				GL11.glRotatef(0.1F * ticks % 180.0F, 0.0F, 1.0F, 0.0F);

				EntityItem entityitem = null;
				ItemStack is = container.getStackInSlot(0).copy();
				is.stackSize = 1;
				entityitem = new EntityItem(container.getWorldObj(), 0.0D, 0.0D, 0.0D, is);
				entityitem.hoverStart = 0.0F;

				RenderManager.instance.renderEntityWithPosYaw(entityitem, 0.0D, 0.0D, 0.0D, 0.0F, 0.0F);

				if(container.mode == 2 && container.items[0].stackSize >= 2 && Block.getBlockFromItem(container.items[0].getItem()) == Blocks.cactus){
					RenderManager.instance.renderEntityWithPosYaw(entityitem, 0.0D, 0.25D, 0.0D, 0.0F, 0.0F);
				}
				GL11.glPopMatrix();
			}
		}
	}

}

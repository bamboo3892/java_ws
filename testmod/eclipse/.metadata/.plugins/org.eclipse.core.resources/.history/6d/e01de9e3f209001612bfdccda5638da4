package com.test.multiblock.construct.tileentity;

import java.util.ArrayList;

import com.test.inventory.AbstractFilter;
import com.test.inventory.IFilterUser;
import com.test.main.GuiHandler.IGuiTile;
import com.test.main.TestCore;
import com.test.multiblock.BlockPipeTileEntity;
import com.test.network.SimpleTilePacket;
import com.test.network.SimpleTilePacket.PacketType;
import com.test.utils.ConnectionEntry;
import com.test.utils.Position;
import com.test.utils.RectangularSolid;

import buildcraft.api.tools.IToolWrench;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.ChatComponentText;
import net.minecraft.world.World;
import net.minecraftforge.common.util.ForgeDirection;

public class ConstructDispatcherTileEntity extends ConstructBaseTileEntity implements IPipeConnectionUser, IConstructInventory, IFilterUser, IGuiTile, ISignalReceiver {

	public static final String nameForNBT = "dispatcher";
	public static final int[] maxTransfer = { 1, 4, 16, 32, 64 };
	public static final int[] filterCapability = { 0, 2, 4, 5, 6 };

	public int stackLimit = 1;
	public ItemStack containingItem;

	private ArrayList<ConnectionEntry>[] invConnect = new ArrayList[6];
	private ArrayList<ConnectionEntry> signalReceivers = new ArrayList();
	private AbstractFilter[] filter = new AbstractFilter[6];
	private int sidePointer;
	private int indexPointer;

	public ConstructDispatcherTileEntity() {
		this(0);
	}

	public ConstructDispatcherTileEntity(int grade) {
		super(grade);
		for (int i = 0; i < 6; i++){
			invConnect[i] = new ArrayList();
		}
	}

	@Override
	public void onRightClicked(EntityPlayer player, int side, float hitX, float hitY, float hitZ) {
		//open gui
	}

	@Override
	public void onShiftRightClicked(EntityPlayer player, int side, float hitX, float hitY, float hitZ) {
		if(worldObj.isRemote){
			this.spawnCennectionParticle();
		}
	}

	@Override
	public boolean onRightClickedByWrench(EntityPlayer player, int side, float hitX, float hitY, float hitZ) {
		if(player.getCurrentEquippedItem() == null || !(player.getCurrentEquippedItem().getItem() instanceof IToolWrench)) return false;
		//checkConnection();
		if(!player.isSneaking()){
			int n = changeIO(side);
			ForgeDirection dir = ForgeDirection.getOrientation(side);
			if(worldObj.getTileEntity(xCoord + dir.offsetX, yCoord + dir.offsetY, zCoord + dir.offsetZ) instanceof BlockPipeTileEntity){
				((BlockPipeTileEntity) worldObj.getTileEntity(xCoord + dir.offsetX, yCoord + dir.offsetY, zCoord + dir.offsetZ)).checkConnection();
			}
			TestCore.proxy.markForTileUpdate(new Position(xCoord, yCoord, zCoord), PacketType.FLAG_IO);
			if(worldObj.isRemote) player.addChatMessage(new ChatComponentText(n == 0 ? "input" : n == 1 ? "output" : "disabled"));
		}else{
			if(worldObj.isRemote){
				//do nothing
			}else{
				//update all connection
				this.checkAllConnection();
				TestCore.packetDispatcher.sendToAll(new SimpleTilePacket(this, PacketType.EFFECT, 0));
				player.addChatMessage(new ChatComponentText("Update All the Connections"));
			}
		}
		return false;
	}

	public int changeIO(int side) {
		if(side < 0 || side >= 6) return 3;
		flagIO[side] = flagIO[side] == 2 ? 0 : flagIO[side] + 1;
		return flagIO[side];
	}

	private boolean needUpdateEntry = true;

	@Override
	public void updateEntity() {
		super.updateEntity();
		if(worldObj.isRemote){
			//do nothing
		}else{
			if(needUpdateEntry){
				checkAllConnection();
				needUpdateEntry = false;
			}
		}
	}

	private void checkAllConnection() {
		ArrayList<BlockPipeTileEntity> checkedPipes = new ArrayList<BlockPipeTileEntity>();
		for (int side = 0; side < 6; side++){
			invConnect[side].clear();
			invConnect[side].add(new ConnectionEntry(this, ForgeDirection.getOrientation(side).ordinal()));
			ForgeDirection dir = ForgeDirection.getOrientation(side);
			int newX = xCoord + dir.offsetX;
			int newY = yCoord + dir.offsetY;
			int newZ = zCoord + dir.offsetZ;
			TileEntity tile = worldObj.getTileEntity(newX, newY, newZ);
			if(tile instanceof BlockPipeTileEntity && !tile.isInvalid()){
				BlockPipeTileEntity pipe = (BlockPipeTileEntity) tile;
				pipe.findConnection(checkedPipes, invConnect[side], IConstructInventory.class, true);
			}else if(tile != null && tile instanceof IConstructInventory){
				if(tile instanceof ConstructBaseTileEntity){
					ConstructBaseTileEntity baseTile = (ConstructBaseTileEntity) tile;
					if(baseTile.flagIO[dir.getOpposite().ordinal()] == 0){
						invConnect[side].add(new ConnectionEntry((IConstructInventory) baseTile, ForgeDirection.getOrientation(side).getOpposite().ordinal()));
					}
				}
			}
			invConnect[side].remove(0);
		}

		signalReceivers.clear();
		signalReceivers.add(new ConnectionEntry(this));
		checkedPipes.clear();
		for (int side = 0; side < 6; side++){
			ForgeDirection dir = ForgeDirection.getOrientation(side);
			int newX = xCoord + dir.offsetX;
			int newY = yCoord + dir.offsetY;
			int newZ = zCoord + dir.offsetZ;
			TileEntity tile = worldObj.getTileEntity(newX, newY, newZ);
			if(tile instanceof BlockPipeTileEntity && !tile.isInvalid()){
				BlockPipeTileEntity pipe = (BlockPipeTileEntity) tile;
				pipe.findConnection(checkedPipes, signalReceivers, ISignalReceiver.class, false);
			}else if(tile != null && tile instanceof ISignalReceiver){
				if(tile instanceof ConstructBaseTileEntity){
					ConstructBaseTileEntity baseTile = (ConstructBaseTileEntity) tile;
					if(baseTile.flagIO[dir.getOpposite().ordinal()] == 0){
						signalReceivers.add(new ConnectionEntry((ISignalReceiver) baseTile));
					}
				}
			}
		}
		signalReceivers.remove(0);
	}

	private boolean itemTransfer(int maxTransfer) {//dont use priority
		if(worldObj.isRemote) throw new NullPointerException("called on invalid side : " + (worldObj.isRemote ? "Client" : "Server"));

		return false;
	}

	/**client only*/
	private void spawnCennectionParticle() {
		if(!worldObj.isRemote) throw new NullPointerException("called on invalid side : " + (worldObj.isRemote ? "Client" : "Server"));
		this.checkAllConnection();
		for (int side = 0; side < 6; side++){
			for (ConnectionEntry entry : invConnect[side]){
				if(worldObj.getTileEntity(entry.x, entry.y, entry.z) instanceof ConstructBaseTileEntity){
					ConstructBaseTileEntity baseTile = (ConstructBaseTileEntity) worldObj.getTileEntity(entry.x, entry.y, entry.z);
					baseTile.restRenderTicks = 100;
					baseTile.renderSide = entry.side;
				}
			}
		}
		for (ConnectionEntry entry : signalReceivers){
			if(worldObj.getTileEntity(entry.x, entry.y, entry.z) instanceof ConstructBaseTileEntity){
				ConstructBaseTileEntity baseTile = (ConstructBaseTileEntity) worldObj.getTileEntity(entry.x, entry.y, entry.z);
				baseTile.restRenderTicks = 100;
				baseTile.renderSide = entry.side;
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	@Override
	public void onSignalReceived() {
		for (ConnectionEntry<ISignalReceiver> receiver : signalReceivers){
			if(receiver != null && receiver.hasTile()){
				receiver.getTile().onSignalReceived();
			}
		}
	}

	@Override
	public SimpleTilePacket getPacket(PacketType type) {
		if(type == PacketType.NBT_CONTENT){
			NBTTagCompound tag = new NBTTagCompound();
			if(this.containingItem != null){
				this.containingItem.writeToNBT(tag);
			}
			return new SimpleTilePacket(this, PacketType.NBT_CONTENT, tag);
		}
		return super.getPacket(type);
	}

	@Override
	public void processCommand(PacketType type, Object value) {
		super.processCommand(type, value);
		if(type == PacketType.EFFECT){
			this.spawnCennectionParticle();
		}else if(type == PacketType.NBT_CONTENT && value instanceof NBTTagCompound){
			NBTTagCompound tag = (NBTTagCompound) value;
			this.containingItem = ItemStack.loadItemStackFromNBT(tag);
		}
	}

	@Override
	public int[] getAccessibleSlotsFromSide(int slotIndex) {
		return new int[] { 0 };
	}
	@Override
	public int getSizeInventory() {
		return 1;
	}
	@Override
	public String getInventoryName() {
		return "Dispatcher";
	}
	@Override
	public boolean hasCustomInventoryName() {
		return false;
	}
	@Override
	public int getInventoryStackLimit() {
		return this.stackLimit;
	}
	@Override
	public void openInventory() {}
	@Override
	public void closeInventory() {}
	@Override
	public ItemStack getStackInSlot(int slotIndex) {
		if(slotIndex == 0) return this.containingItem;
		return null;
	}
	@Override
	public ItemStack decrStackSize(int slotIndex, int amount) {
		if(slotIndex == 0 && this.containingItem != null){
			if(this.containingItem.stackSize <= amount){
				ItemStack tmpItemStack = this.containingItem.copy();
				this.containingItem = null;
				this.markDirty();
				return tmpItemStack;
			}
			ItemStack splittedItemStack = this.containingItem.splitStack(amount);
			if(this.containingItem.stackSize == 0){
				this.containingItem = null;
			}
			this.markDirty();
			return splittedItemStack;
		}
		return null;
	}
	@Override
	public ItemStack getStackInSlotOnClosing(int slotIndex) {
		if(slotIndex == 0){
			return this.containingItem;
		}
		return null;
	}
	@Override
	public void setInventorySlotContents(int slotIndex, ItemStack itemStack) {
		if(slotIndex == 0){
			this.containingItem = itemStack;
			if(itemStack != null && itemStack.stackSize > getInventoryStackLimit()){
				itemStack.stackSize = getInventoryStackLimit();
			}
		}
	}
	@Override
	public boolean isUseableByPlayer(EntityPlayer player) {
		if(worldObj.getTileEntity(xCoord, yCoord, zCoord) != this){
			return false;
		}
		return player.getDistanceSq((double) xCoord + 0.5D, (double) yCoord + 0.5D, (double) zCoord + 0.5D) <= 50000.0D;
	}
	@Override
	public boolean isItemValidForSlot(int slotIndex, ItemStack itemStack) {
		if(slotIndex == 0 && !worldObj.isRemote){
			ItemStack itemCopy = itemStack.copy();
			itemCopy.stackSize = 1;
			for (int side = 0; side < 6; side++){
				if(this.canExtractItem(slotIndex, itemStack, side)){
					for (ConnectionEntry entry : invConnect[side]){
						if(entry != null && entry.getTile() != null){
							IConstructInventory inv = (IConstructInventory) entry.getTile();
							for (int slot : inv.getAccessibleSlotsFromSide(entry.side)){
								if(inv.isItemValidForSlot(slot, itemCopy) && inv.canInsertItem(slot, itemCopy, side)){
									return true;
								}
							}
						}
					}
				}
			}
		}
		return false;
	}
	@Override
	public boolean canInsertItem(int slotIndex, ItemStack itemStack, int side) {
		// TODO 自動生成されたメソッド・スタブ
		return false;
	}
	@Override
	public boolean canExtractItem(int slotIndex, ItemStack itemStack, int side) {
		// TODO 自動生成されたメソッド・スタブ
		return false;
	}

	@Override
	public void needUpdateEntry() {
		needUpdateEntry = true;
	}

	@Override
	public Object getGuiElement(EntityPlayer player, int side, boolean serverSide) {
		//		Object elem = super.getGuiElement(player, side, serverSide);
		//		if(elem == null){
		//			return serverSide ? new ConstructContainerContainer(player.inventory, this) : new ConstructContainerGui(player.inventory, this);
		//		}else{
		//			return elem;
		//		}
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	@Override
	public void writeDetailToNBTForItemStack(NBTTagCompound tag, RectangularSolid solid) {
		super.writeDetailToNBTForItemStack(tag, solid);
	}

	@Override
	public String getNameForNBT() {
		return nameForNBT;
	}

	@Override
	public void readFromNBT(NBTTagCompound nbtTagCompound) {
		super.readFromNBT(nbtTagCompound);
	}

	@Override
	public void writeToNBT(NBTTagCompound nbtTagCompound) {
		super.writeToNBT(nbtTagCompound);
	}

	@Override
	public boolean setFilter(int side, AbstractFilter filter) {
		// TODO 自動生成されたメソッド・スタブ
		return false;
	}

	@Override
	public AbstractFilter getFilter(int side) {
		// TODO 自動生成されたメソッド・スタブ
		return null;
	}

	@Override
	public ItemStack removeFilter(int side) {
		// TODO 自動生成されたメソッド・スタブ
		return null;
	}

	@Override
	public World getWorldObject() {
		// TODO 自動生成されたメソッド・スタブ
		return null;
	}

	@Override
	public void updateFilter() {
		// TODO 自動生成されたメソッド・スタブ

	}

}
